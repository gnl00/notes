---
description: PostgreSQL 多个列与 JSON/Array 列空间占用对比
tag: 
  - PostgreSQL
  - 数据库
---



# PostgreSQL 多个列与 JSON/Array 列空间占用对比



## PG 多字段 float 与 JSON 类型占用对比

目前有一个表  sensor_ readings，用于记录多个传感器采集到的实时读数。由于每个传感器单独作为一个字段，表结构如下：

```
time 
sensor_1
sensor_2
...
sensor_n
```

随着传感器数量的增加，需要不断添加字段来匹配。这样**很不优雅，也不利于后期扩展**。

使用 PG 的 JSON 格式来存储数据。

只需要一个字段

```
time
...
readings: {
	sensor_1
  sensor_2
  ...
  sensor_100
}
```

就算后续需要新增数据，也只要在 temp 字段中新增即可

```
time
...
readings: {
	sensor_1
  sensor_2
  ...
  sensor_100
  ...
  sensor_110
}
```

便捷，不用修改表结构。非常不错。

接下来的问题是存储这一段 JSON 数据的空间占用和存储一个百多个 float 占用的空间对比了。

```sql
-- 查询某一列需要使用多少存储空间，返回字节数=byte
select pg_column_size(3.416); -- 10
select pg_column_size(3.372); -- 10
select pg_column_size(3.4); -- 10
```

10 * 129 = 1290 byte

```sql
select pg_column_size('{"sensor":{"sensor_1":3.396,"sensor_2":3.35,"sensor_3":3.4,"sensor_4":3.388,"sensor_5":3.385,"sensor_6":3.382,"sensor_7":3.386,"sensor_8":3.345,"sensor_9":3.349,"sensor_10":3.342,"sensor_11":3.382,"sensor_12":3.386,"sensor_13":3.36,"sensor_14":3.344,"sensor_15":3.382,"sensor_16":3.345,"sensor_17":3.34,"sensor_18":3.334,"sensor_19":3.362,"sensor_20":3.373,"sensor_21":3.35,"sensor_22":3.345,"sensor_23":3.347,"sensor_24":3.396,"sensor_25":3.35,"sensor_26":3.353,"sensor_27":3.385,"sensor_28":3.359,"sensor_29":3.375,"sensor_30":3.362,"sensor_31":3.369,"sensor_32":3.367,"sensor_33":3.363,"sensor_34":3.398,"sensor_35":3.393,"sensor_36":3.354,"sensor_37":3.396,"sensor_38":3.396,"sensor_39":3.4,"sensor_40":3.392,"sensor_41":3.367,"sensor_42":3.399,"sensor_43":3.399,"sensor_44":3.358,"sensor_45":3.35,"sensor_46":3.345,"sensor_47":3.406,"sensor_48":3.395,"sensor_49":3.38,"sensor_50":3.416,"sensor_51":3.413,"sensor_52":3.406,"sensor_53":3.415,"sensor_54":3.409,"sensor_55":3.401,"sensor_56":3.401,"sensor_57":3.409,"sensor_58":3.409,"sensor_59":3.363,"sensor_60":3.365,"sensor_61":3.408,"sensor_62":3.398,"sensor_63":3.403,"sensor_64":3.357,"sensor_65":3.395,"sensor_66":3.363,"sensor_67":3.418,"sensor_68":3.408,"sensor_69":3.369,"sensor_70":3.405,"sensor_71":3.391,"sensor_72":3.391,"sensor_73":3.37,"sensor_74":3.365,"sensor_75":3.408,"sensor_76":3.367,"sensor_77":3.411,"sensor_78":3.375,"sensor_79":3.379,"sensor_80":3.409,"sensor_81":3.373,"sensor_82":3.363,"sensor_83":3.408,"sensor_84":3.368,"sensor_85":3.403,"sensor_86":3.413,"sensor_87":3.402,"sensor_88":3.396,"sensor_89":3.398,"sensor_90":3.395,"sensor_91":3.35, "sensor_92":3.4, "sensor_93":3.39, "sensor_94":3.401, "sensor_95":3.405, "sensor_96":3.41, "sensor_97":3.412, "sensor_98":3.399, "sensor_99":3.408, "sensor_100":3.407, "sensor_101":3.405, "sensor_102":3.402, "sensor_103":3.397, "sensor_104":3.395, "sensor_105":3.386, "sensor_106":3.381, "sensor_107":3.379, "sensor_108":3.388, "sensor_109":3.393, "sensor_110":3.399, "sensor_111":3.404, "sensor_112":3.412, "sensor_113":3.406, "sensor_114":3.402, "sensor_115":3.405, "sensor_116":3.398, "sensor_117":3.393, "sensor_118":3.388, "sensor_119":3.381, "sensor_120":3.375, "sensor_121":3.372, "sensor_122":3.367, "sensor_123":3.363, "sensor_124":3.358, "sensor_125":3.352, "sensor_126":3.347, "sensor_127":3.341, "sensor_128":3.336, "sensor_129":3.331}}'::json);
```

2120 byte

…

虽然但是，没想到结果居然…JSON 列占用的空间差不多是多列存储的 2 倍。

一条数据多 1kb，一个 sensor 一个月大概有 250 万条数据= 1kb * 250w = 25000000kb ≈ 2440MB ≈ 2GB。

一个 sensor 一个月多 2GB，目前有 50 个 sensor = 100GB，将来还要上到 100 个 sensor = 200GB。

多出来的空间占用还是比较大的。

…

## PG 多字段 float 与 Array 类型占用对比

```sql
select pg_column_size(Array[3.396, 3.35, 3.4, 3.388, 3.385, 3.382, 3.386, 3.345, 3.349, 3.342, 3.382, 3.386, 3.36, 3.344, 3.382, 3.345, 3.34, 3.334, 3.362, 3.373, 3.35, 3.345, 3.347, 3.396, 3.35, 3.353, 3.385, 3.359, 3.375, 3.362, 3.369, 3.367, 3.363, 3.398, 3.393, 3.354, 3.396, 3.396, 3.4, 3.392, 3.367, 3.399, 3.399, 3.358, 3.35, 3.345, 3.406, 3.395, 3.38, 3.416, 3.413, 3.406, 3.415, 3.409, 3.401, 3.401, 3.409, 3.409, 3.363, 3.365, 3.408, 3.398, 3.403, 3.357, 3.395, 3.363, 3.418, 3.408, 3.369, 3.405, 3.391, 3.391, 3.37, 3.365, 3.408, 3.367, 3.411, 3.375, 3.379, 3.409, 3.373, 3.363, 3.408, 3.368, 3.403, 3.413, 3.402, 3.396, 3.398, 3.395, 3.35, 3.354, 3.4, 3.314, 3.356, 3.309, 3.359, 3.334, 3.358, 3.358, 3.363, 3.367, 3.36, 3.363, 3.334, 3.365, 3.32, 3.314, 3.314, 3.311, 3.355, 3.316, 3.323, 3.321, 3.317, 3.363, 3.324, 3.369, 3.412, 3.4, 3.383, 3.416, 3.413, 3.409, 3.415, 3.378, 3.368, 3.357, 3.357]);
```

1572 byte

…

---

## 再续 Array 前缘

在一次偶然的尝试中，我将 Array 中的数字类型转成 real=float4。然后尝试查询空间大小：

```sql
select pg_column_size(Array[3.396::real, 3.35, 3.4, 3.388, 3.385, 3.382, 3.386, 3.345, 3.349, 3.342, 3.382, 3.386, 3.36, 3.344, 3.382, 3.345, 3.34, 3.334, 3.362, 3.373, 3.35, 3.345, 3.347, 3.396, 3.35, 3.353, 3.385, 3.359, 3.375, 3.362, 3.369, 3.367, 3.363, 3.398, 3.393, 3.354, 3.396, 3.396, 3.4, 3.392, 3.367, 3.399, 3.399, 3.358, 3.35, 3.345, 3.406, 3.395, 3.38, 3.416, 3.413, 3.406, 3.415, 3.409, 3.401, 3.401, 3.409, 3.409, 3.363, 3.365, 3.408, 3.398, 3.403, 3.357, 3.395, 3.363, 3.418, 3.408, 3.369, 3.405, 3.391, 3.391, 3.37, 3.365, 3.408, 3.367, 3.411, 3.375, 3.379, 3.409, 3.373, 3.363, 3.408, 3.368, 3.403, 3.413, 3.402, 3.396, 3.398, 3.395, 3.35, 3.354, 3.4, 3.314, 3.356, 3.309, 3.359, 3.334, 3.358, 3.358, 3.363, 3.367, 3.36, 3.363, 3.334, 3.365, 3.32, 3.314, 3.314, 3.311, 3.355, 3.316, 3.323, 3.321, 3.317, 3.363, 3.324, 3.369, 3.412, 3.4, 3.383, 3.416, 3.413, 3.409, 3.415, 3.378, 3.368, 3.357, 3.357]);
```

**540**！

占用空间只有多列字符串的一半，甚至更少！

> *PostgreSQL 会根据第一个元素的类型，推断整个数组的元素类型。*

再看看原数组

```sql
select pg_column_size(Array[3.396, 3.35, 3.4, 3.388, 3.385, 3.382, 3.386, 3.345, 3.349, 3.342, 3.382, 3.386, 3.36, 3.344, 3.382, 3.345, 3.34, 3.334, 3.362, 3.373, 3.35, 3.345, 3.347, 3.396, 3.35, 3.353, 3.385, 3.359, 3.375, 3.362, 3.369, 3.367, 3.363, 3.398, 3.393, 3.354, 3.396, 3.396, 3.4, 3.392, 3.367, 3.399, 3.399, 3.358, 3.35, 3.345, 3.406, 3.395, 3.38, 3.416, 3.413, 3.406, 3.415, 3.409, 3.401, 3.401, 3.409, 3.409, 3.363, 3.365, 3.408, 3.398, 3.403, 3.357, 3.395, 3.363, 3.418, 3.408, 3.369, 3.405, 3.391, 3.391, 3.37, 3.365, 3.408, 3.367, 3.411, 3.375, 3.379, 3.409, 3.373, 3.363, 3.408, 3.368, 3.403, 3.413, 3.402, 3.396, 3.398, 3.395, 3.35, 3.354, 3.4, 3.314, 3.356, 3.309, 3.359, 3.334, 3.358, 3.358, 3.363, 3.367, 3.36, 3.363, 3.334, 3.365, 3.32, 3.314, 3.314, 3.311, 3.355, 3.316, 3.323, 3.321, 3.317, 3.363, 3.324, 3.369, 3.412, 3.4, 3.383, 3.416, 3.413, 3.409, 3.415, 3.378, 3.368, 3.357, 3.357]);
```

因为没有指定类型，PostgreSQL 默认所有原数组中的所有元素都是数字类型 numeric。

而 numeric 类型的存储大小是不固定的。

| 名字               | 存储尺寸 | 描述               | 范围                                         |
| ------------------ | -------- | ------------------ | -------------------------------------------- |
| `smallint`         | 2字节    | 小范围整数         | -32768 to +32767                             |
| `integer`          | 4字节    | 整数的典型选择     | -2147483648 to +2147483647                   |
| `bigint`           | 8字节    | 大范围整数         | -9223372036854775808 to +9223372036854775807 |
| `decimal`          | 可变     | 用户指定精度，精确 | 最高小数点前131072位，以及小数点后16383位    |
| `numeric`          | 可变     | 用户指定精度，精确 | 最高小数点前131072位，以及小数点后16383位    |
| `real`             | 4字节    | 可变精度，不精确   | 6位十进制精度                                |
| `double precision` | 8字节    | 可变精度，不精确   | 15位十进制精度                               |
| `smallserial`      | 2字节    | 自动增加的小整数   | 1到32767                                     |
| `serial`           | 4字节    | 自动增加的整数     | 1到2147483647                                |
| `bigserial`        | 8字节    | 自动增长的大整数   | 1到9223372036854775807                       |

比如

```sql
select pg_column_size(3.35); -- 10
```

如果强制转为 real

```sql
select pg_column_size(3.35::real); -- 4
```

空间占用就会下降很多。

…

---

总结一下：

* 占用：Array::real < 多列 < JSON
* 可扩展性：Array::real = JSON > 多列

最后，无论是从可扩展的角度还是空间占用的角度来看，使用 Array 来存储都是比较好的选择。

…